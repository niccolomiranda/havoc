class SliderUIController { constructor() { this.bind() } init(e) { this.projects = e, this.nameList = document.querySelector(".names"), this.nameHolder = document.querySelector(".name-holder"), this.numberList = document.querySelector(".numbers"), document.querySelector(".slide-number").innerHTML = e.length, this.offsetY = 0, this.stepSize = 0, this.lastSlide = 0, this.populate() } populate() { this.projects.forEach((e, t) => { if (0 == t) { let e = document.createElement("li"); e.innerHTML = this.projects[this.projects.length - 1].name, this.nameList.appendChild(e), window.isMobile && e.addEventListener("click", () => { window.location.href = this.projects[this.projects.length - 1].projUrl }); let t = document.createElement("li"); t.innerHTML = this.projects.length, this.numberList.appendChild(t) } let n = document.createElement("li"); n.innerHTML = e.name, this.nameList.appendChild(n), window.isMobile && n.addEventListener("click", () => { window.location.href = e.projUrl }); let i = document.createElement("li"); if (i.innerHTML = t + 1, this.numberList.appendChild(i), t == this.projects.length - 1) { let e = document.createElement("li"); e.innerHTML = this.projects[0].name, this.nameList.appendChild(e), window.isMobile && e.addEventListener("click", () => { window.location.href = this.projects[0].projUrl }); let t = document.createElement("li"); t.innerHTML = 1, this.numberList.appendChild(t) } }), this.nameList.style.top = "-100%", this.numberList.style.top = "-100%" } slideTo(e) { this.lastSlide == this.nameList.childNodes.length - 2 && 1 == e && (this.nameList.style.top = "-100%", this.numberList.style.top = "-100%"), -1 == this.lastSlide && e == this.nameList.childNodes.length - 4 && (this.nameList.style.top = `${-100 * (this.nameList.childNodes.length - 2)}%`, this.numberList.style.top = `${-100 * (this.nameList.childNodes.length - 2)}%`), TweenLite.to(this.nameList, sliderConfig.uiAnimTime, { top: `${-100 * (e + 1)}%` }), TweenLite.to(this.numberList, sliderConfig.uiAnimTime, { top: `${-100 * (e + 1)}%` }), this.lastSlide = e } bind() { this.init = this.init.bind(this), this.populate = this.populate.bind(this), this.slideTo = this.slideTo.bind(this) } } const map = " \nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n", noise3 = "vec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }", vernoiNoise = "  \nconst mat2 myt = mat2(.12121212, .13131313, -.13131313, .12121212);\nconst vec2 mys = vec2(1e4, 1e6);\n\nvec2 rhash(vec2 uv) {\n  uv *= myt;\n  uv *= mys;\n  return fract(fract(uv / mys) * uv);\n}\n\nvec3 hash(vec3 p) {\n  return fract(\n      sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)), dot(p, vec3(57.0, 113.0, 1.0)),\n               dot(p, vec3(113.0, 1.0, 57.0)))) *\n      43758.5453);\n}\n\nvec3 voronoi3d(const in vec3 x) {\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n\n  float id = 0.0;\n  vec2 res = vec2(100.0);\n  for (int k = -1; k <= 1; k++) {\n    for (int j = -1; j <= 1; j++) {\n      for (int i = -1; i <= 1; i++) {\n        vec3 b = vec3(float(i), float(j), float(k));\n        vec3 r = vec3(b) - f + hash(p + b);\n        float d = dot(r, r);\n\n        float cond = max(sign(res.x - d), 0.0);\n        float nCond = 1.0 - cond;\n\n        float cond2 = nCond * max(sign(res.y - d), 0.0);\n        float nCond2 = 1.0 - cond2;\n\n        id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);\n        res = vec2(d, res.x) * cond + res * nCond;\n\n        res.y = cond2 * d + nCond2 * res.y;\n      }\n    }\n  }\n\n  return vec3(sqrt(res), abs(id));\n}"; function vertexShader() { return "\n      varying vec2 vUv; \n      varying vec3 vPos; \n\n      void main() {\n        vUv = uv; \n        vPos = position; \n\n        vec3 pos = position;\n\n        vec4 modelViewPosition = modelViewMatrix * vec4(pos, 1.0);\n        gl_Position = projectionMatrix * modelViewPosition; \n      }\n    " } function fragmentShaderFlow() { return noise3 + "\n    varying vec2 vUv; \n    varying vec3 vPos; \n    \n    uniform float uTime;\n    uniform float uWiggleInt;\n    uniform float uTexMix;\n\n    uniform sampler2D uTexFrom;\n    uniform sampler2D uTexTo;\n\n    uniform vec2 uRepeatFrom;\n    uniform vec2 uOffsetFrom;\n    uniform vec2 uRepeatTo;\n    uniform vec2 uOffsetTo;\n\n\n    uniform float uNoiseDist;\n    uniform float uWaveDist;\n    uniform float uVertDist;\n\n    \n    void main() {\n      vec2 nUv = vUv;\n      nUv.x*=5.;\n      nUv.x+=sin(nUv.y*50.)*uWaveDist;\n      float n = snoise(vec3(nUv*uNoiseDist, uTime*0.1));\n\n      vec2 fromUv = vUv;\n      fromUv*=uRepeatFrom;\n      fromUv+=uOffsetFrom;\n      \n      fromUv.y+=n*uWiggleInt;\n\n      vec2 toUv = vUv;\n      toUv*=uRepeatTo;\n      toUv+=uOffsetTo;\n\n      toUv.y+=n*(1.-uWiggleInt);\n\n      vec4 fromTex = texture2D(uTexFrom, fromUv);\n      vec4 toTex = texture2D(uTexTo, toUv);\n\n\n      float sN = step(n, uTexMix);\n\n      vec4 col = mix(fromTex,toTex, uTexMix);\n      gl_FragColor = vec4(col);\n       //gl_FragColor = vec4(flowTex);\n    }\n" } class ThreeSlider { constructor() { this.bind(), this.camera, this.scene, this.renderer, this.controls, this.textureLoader = new THREE.TextureLoader, this.currSlide = -1, this.transSlide = 0, this.mouseXClick = null, this.downFlag = !1, this.releaseFlag = !0, this.mousePos = new THREE.Vector2(-2e3, 2e3) } init(e, t, n) { this.imgs = t, this.imgTextures = [], this.animTime = sliderConfig.glAnimTime, this.mouseAnimTime = .5, this.container = e, this.contWidth = e.offsetWidth, this.contHeight = e.offsetHeight, this.renderer = new THREE.WebGLRenderer({ antialias: !0 }), this.renderer.setSize(e.offsetWidth, e.offsetHeight), this.renderer.debug.checkShaderErrors = !0, e.appendChild(this.renderer.domElement), this.renderer.setPixelRatio(window.devicePixelRatio), this.scene = new THREE.Scene, this.camera = new THREE.OrthographicCamera(this.contWidth / -2, this.contWidth / 2, this.contHeight / 2, this.contHeight / -2, 1, 1e3), this.camera.position.set(0, 0, 200), this.container.addEventListener("mousedown", this.onDown), this.container.addEventListener("mouseup", this.onUp), this.container.addEventListener("mouseleave", this.onUp), this.container.addEventListener("mousemove", this.onMove), this.loadImgs(), this.lastContSize = [window.innerWidth, window.innerHeight], window.addEventListener("mousemove", this.mouseMove), RAF.subscribe("threeSceneUpdate", this.update) } loadImgs() { this.imgs.forEach((e, t) => { let n = this.textureLoader.load(e, e => { let i = this.contWidth / this.contHeight, s = e.image.width / e.image.height, o = 1, r = i / s; r > 1 && (r = 1, o = s / i), n.repeat.set(r, o), n.offset.set((1 - r) / 2, (1 - o) / 2), n.needsUpdate = !0, this.imgTextures[t] = n, this.imgTextures.length == this.imgs.length && this.imagesLoaded() }) }) } imagesLoaded() { this.uniforms = { uTime: { value: 0 }, uTexMix: { value: 0 }, uWiggleInt: { value: 0 }, uTexFrom: { value: this.imgTextures[0] }, uTexTo: { value: this.imgTextures[0] }, uRepeatFrom: { value: this.imgTextures[0].repeat }, uOffsetFrom: { value: this.imgTextures[0].offset }, uRepeatTo: { value: this.imgTextures[0].repeat }, uOffsetTo: { value: this.imgTextures[0].offset }, uNoiseDist: { value: sliderConfig.uNoiseDist }, uWaveDist: { value: sliderConfig.uWaveDist }, uVertDist: { value: sliderConfig.uVertDist } }, this.imgPlane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), new THREE.ShaderMaterial({ uniforms: this.uniforms, vertexShader: vertexShader(), fragmentShader: fragmentShaderFlow() })), this.imgPlane.scale.x = this.contWidth, this.imgPlane.scale.y = this.contHeight, this.scene.add(this.imgPlane) } slideTo(e) { this.currSlide = e, this.uniforms.uTexFrom.value = this.uniforms.uTexTo.value, this.uniforms.uTexTo.value = this.imgTextures[e], this.uniforms.uRepeatFrom.value = this.uniforms.uTexFrom.value.repeat, this.uniforms.uRepeatTo.value = this.uniforms.uTexTo.value.repeat, this.uniforms.uOffsetFrom.value = this.uniforms.uTexFrom.value.offset, this.uniforms.uOffsetTo.value = this.uniforms.uTexTo.value.offset, this.uniforms.uTexMix.value = 0, this.uniforms.uWiggleInt.value = 0, TweenLite.to(this.uniforms.uTexMix, this.animTime, { value: 1, ease: Power2.easeOut }), TweenLite.to(this.uniforms.uWiggleInt, this.animTime, { value: 1, ease: Power1.easeOut }) } update() { (this.lastContSize[0] != window.innerWidth || window.innerHeight) && this.resizeCanvas(), this.lastContSize = [window.innerWidth, window.innerHeight], null != this.uniforms && (this.uniforms.uTime.value += .01 * RAF.dt), this.renderer.render(this.scene, this.camera), this.renderer.setRenderTarget(null) } resizeCanvas() { this.contWidth = this.container.offsetWidth, this.contHeight = this.container.offsetHeight, this.renderer.setSize(this.contWidth, this.contHeight), this.camera.aspect = window.innerWidth / window.innerHeight, this.camera.updateProjectionMatrix(), this.camera.top = this.contHeight / 2, this.camera.bottom = this.contHeight / -2, this.camera.left = this.contWidth / -2, this.camera.right = this.contWidth / 2, null != this.imgPlane && (this.imgPlane.scale.x = this.contWidth, this.imgPlane.scale.y = this.contHeight, this.imgTextures.forEach((e, t) => { let n = this.contWidth / this.contHeight, i = e.image.width / e.image.height, s = 1, o = n / i; o > 1 && (o = 1, s = i / n), e.repeat.set(o, s), e.offset.set((1 - o) / 2, (1 - s) / 2), e.needsUpdate = !0 })) } mouseMove(e) { this.mousePos.x = e.clientX / window.innerWidth * 2 - 1, this.mousePos.y = -e.clientY / window.innerHeight * 2 + 1 } bind() { this.resizeCanvas = this.resizeCanvas.bind(this), this.update = this.update.bind(this), this.init = this.init.bind(this), this.loadImgs = this.loadImgs.bind(this), this.slideTo = this.slideTo.bind(this), this.mouseMove = this.mouseMove.bind(this) } }